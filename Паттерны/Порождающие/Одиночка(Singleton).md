Паттерн **"Singleton"** (Одиночка) в C++ используется для создания единственного экземпляра класса, который доступен глобально. Он гарантирует, что класс имеет только один экземпляр и предоставляет глобальную точку доступа к этому экземпляру. Это полезно для управления ресурсами, настройками конфигурации и другими объектами, которые должны существовать в единственном экземпляре.

```cpp
#include <iostream>
#include <mutex>

class Singleton
{
public:
    // Удаление операторов копирования и присваивания для предотвращения копирования экземпляра
    Singleton(const Singleton&)            = delete;
    Singleton& operator=(const Singleton&) = delete;

    // Метод для получения единственного экземпляра класса
    static Singleton& getInstance()
    {
        static Singleton instance;
        return instance;
    }

    void someBusinessLogic()
    {
        // Логика вашего бизнеса
        std::cout << "Executing some business logic." << std::endl;
    }

private:
    // Приватный конструктор для предотвращения создания экземпляров вне класса
    Singleton()
    {
        std::cout << "Singleton instance created." << std::endl;
    }

    // Приватный деструктор для предотвращения удаления экземпляров вне класса
    ~Singleton() = default;
};
```
main():
```cpp
int main()
{
    // Получаем единственный экземпляр Singleton и выполняем бизнес-логику
    Singleton& singleton = Singleton::getInstance();
    singleton.someBusinessLogic();

    // Попытка создать еще один экземпляр приведет к ошибке компиляции
    // Singleton anotherInstance = Singleton::getInstance(); // Ошибка компиляции

    return 0;
}
```
### Описание:
1. Приватный конструктор и деструктор: Конструктор и деструктор объявлены как приватные, чтобы предотвратить создание и уничтожение экземпляров класса вне класса.
2. Удаленные операторы копирования и присваивания: Операторы копирования и присваивания удалены, чтобы предотвратить копирование экземпляра `Singleton`.
3. Статический метод `getInstance()`: Этот метод возвращает ссылку на единственный экземпляр класса `Singleton`. Статическая переменная `instance` создается при первом вызове метода и уничтожается автоматически при завершении программы.
4. Метод `someBusinessLogic()`: Пример метода, который выполняет бизнес-логику.

### Преимущества:
- Гарантирует наличие только одного экземпляра класса.
- Предоставляет глобальную точку доступа к этому экземпляру.
- Ленивая инициализация (экземпляр создается при первом обращении к нему).

### Недостатки:
- Усложняет написание тестов (из-за глобальной доступности экземпляра).
- Может привести к проблемам с многопоточностью, если не реализована соответствующая защита.

### Основная проблема
Когда несколько потоков одновременно пытаются получить доступ к методу `getInstance()`, может возникнуть ситуация гонки данных, в которой два или более потока одновременно создают экземпляры класса. Это нарушит саму суть паттерна "Одиночка", который гарантирует наличие только одного экземпляра.

### Решение с использованием mutex
Использование `std::mutex` помогает синхронизировать доступ к критической секции кода, где создается экземпляр `Singleton`. Рассмотрим пример реализации `Singleton` с использованием `mutex`:
```cpp
#include <iostream>
#include <mutex>

class Singleton
{
public:
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

    static Singleton& getInstance()
    {
        std::lock_guard<std::mutex> guard(mutex_);
        if (instance == nullptr)
        {
            instance = new Singleton();
        }
        return *instance;
    }

    void someBusinessLogic()
    {
        std::cout << "Executing some business logic." << std::endl;
    }

private:
    Singleton()
    {
        std::cout << "Singleton instance created." << std::endl;
    }

    ~Singleton() = default;

    static Singleton* instance;
    static std::mutex mutex_;
};

Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mutex_;
```
main():
```cpp
int main()
{
    Singleton& singleton = Singleton::getInstance();
    singleton.someBusinessLogic();

    return 0;
}
```
### Описание:
1. `std::mutex`: Используется для синхронизации доступа к критической секции, где создается экземпляр Singleton.
2. `std::lock_guard`: Предоставляет автоматическую блокировку и разблокировку `mutex` в пределах блока кода, в котором он объявлен, обеспечивая исключительный доступ к критической секции.

### Преимущества:
- Потокобезопасность: Гарантирует, что только один поток создаст экземпляр `Singleton` даже в многопоточной среде.
- Надежность: Исключает возможные ошибки, связанные с одновременным доступом нескольких потоков к коду создания экземпляра.

### Недостатки:
- Потенциальное снижение производительности: Блокировка mutex может добавить накладные расходы, особенно если метод `getInstance()` вызывается часто.