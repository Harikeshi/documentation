метод Рунге-Кутты 4-5 порядка с автоматическим подбором шага интегрирования в зависимости от заданной точности:

```cpp
#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

// Функция, описывающая систему дифференциальных уравнений dy/dt = f(t, y)
double f(double t, double y) {
    return -2 * t * y;  // Пример: dy/dt = -2*t*y
}

// Реализация метода Рунге-Кутты 4-5 порядка с адаптивным шагом
void runge_kutta_45(double (*f)(double, double), double y0, double t0, double t_end, double tol, double h0, vector<double>& t, vector<double>& y) {
    t.push_back(t0);
    y.push_back(y0);
    double h = h0;

    while (t.back() < t_end) {
        if (t.back() + h > t_end) {
            h = t_end - t.back();
        }

        // Шаг Рунге-Кутты 4-го порядка
        double k1 = h * f(t.back(), y.back());
        double k2 = h * f(t.back() + h / 5, y.back() + k1 / 5);
        double k3 = h * f(t.back() + 3 * h / 10, y.back() + 3 * k1 / 40 + 9 * k2 / 40);
        double k4 = h * f(t.back() + 4 * h / 5, y.back() + 44 * k1 / 45 - 56 * k2 / 15 + 32 * k3 / 9);
        double k5 = h * f(t.back() + 8 * h / 9, y.back() + 19372 * k1 / 6561 - 25360 * k2 / 2187 + 64448 * k3 / 6561 - 212 * k4 / 729);
        double k6 = h * f(t.back() + h, y.back() + 9017 * k1 / 3168 - 355 * k2 / 33 + 46732 * k3 / 5247 + 49 * k4 / 176 - 5103 * k5 / 18656);

        // Оценка ошибки
        double y4 = y.back() + 35 * k1 / 384 + 500 * k3 / 1113 + 125 * k4 / 192 - 2187 * k5 / 6784 + 11 * k6 / 84;
        double y5 = y.back() + 5179 * k1 / 57600 + 7571 * k3 / 16695 + 393 * k4 / 640 - 92097 * k5 / 339200 + 187 * k6 / 2100 + k6 / 40;

        double error = fabs(y5 - y4);  // Ошибка на шаге

        // Адаптация шага
        if (error < tol) {
            t.push_back(t.back() + h);
            y.push_back(y4);
        }

        // Подбор нового шага
        h *= 0.84 * pow(tol / error, 0.25);
        h = max(h, 0.1 * h0);  // Ограничение минимального шага
        h = min(h, 4.0 * h0);  // Ограничение максимального шага
    }
}

int main() {
    double t0 = 0;      // Начальное время
    double t_end = 2;   // Конечное время
    double y0 = 1;      // Начальное значение y(t0)
    double tol = 1e-6;  // Точность
    double h0 = 0.1;    // Начальный шаг

    vector<double> t;  // Вектор времен
    vector<double> y;  // Вектор значений y

    // Вызов метода Рунге-Кутты 4-5 порядка
    runge_kutta_45(f, y0, t0, t_end, tol, h0, t, y);

    // Вывод результатов
    cout << "Времена: ";
    for (double ti : t) {
        cout << ti << " ";
    }
    cout << endl;

    cout << "Значения y: ";
    for (double yi : y) {
        cout << yi << " ";
    }
    cout << endl;

    return 0;
}
```

### Описание программы:
1. **Функция `f`**:
   - Описывает систему дифференциальных уравнений `dy/dt = f(t, y)`. В данном примере используется уравнение `dy/dt = -2*t*y`.

2. **Функция `runge_kutta_45`**:
   - Реализует метод Рунге-Кутты 4-5 порядка с адаптивным шагом.
   - Принимает на вход функцию `f`, начальные условия `y0` и `t0`, конечное время `t_end`, точность `tol`, начальный шаг `h0`, а также векторы `t` и `y` для хранения результатов.

3. **Адаптация шага**:
   - На каждом шаге вычисляется ошибка, и шаг адаптируется в зависимости от заданной точности.
   - Если ошибка меньше `tol`, шаг принимается, иначе шаг уменьшается.

4. **Пример использования**:
   - Решается дифференциальное уравнение `dy/dt = -2*t*y` с начальным условием `y(0) = 1` на интервале от `t=0` до `t=2`.

5. **Вывод результатов**:
   - Программа выводит времена `t` и соответствующие значения `y`.

### Компиляция и запуск:
Для компиляции и запуска программы используйте команды:
```bash
g++ -o runge_kutta_45 runge_kutta_45.cpp -std=c++11
./runge_kutta_45
```

Этот код позволяет эффективно интегрировать дифференциальные уравнения с автоматическим подбором шага для достижения заданной точности.