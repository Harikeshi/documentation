Понял! Вам нужно, чтобы при нажатии на кнопку (в данном случае, символ `'l'`) состояние менялось, а при повторном нажатии — возвращалось к предыдущему состоянию. Это можно реализовать с помощью **стека** (stack), где каждое новое состояние будет сохраняться, а при откате — извлекаться последнее состояние.

Вот пример на C++:

---

### Пример реализации с использованием стека для отката состояния

```cpp
#include <iostream>
#include <stack>
#include <memory>

// State: интерфейс состояния
class State {
public:
    virtual void handle() = 0;
    virtual ~State() = default;
};

// ConcreteStateA: конкретное состояние A
class ConcreteStateA : public State {
public:
    void handle() override {
        std::cout << "Состояние A" << std::endl;
    }
};

// ConcreteStateB: конкретное состояние B
class ConcreteStateB : public State {
public:
    void handle() override {
        std::cout << "Состояние B" << std::endl;
    }
};

// Context: класс, который управляет состояниями
class Context {
private:
    std::stack<std::shared_ptr<State>> stateStack_; // Стек для хранения состояний

public:
    // Устанавливаем начальное состояние
    void setInitialState(std::shared_ptr<State> state) {
        stateStack_.push(state);
    }

    // Переход к новому состоянию
    void changeState(std::shared_ptr<State> newState) {
        stateStack_.push(newState);
    }

    // Откат к предыдущему состоянию
    void revertState() {
        if (stateStack_.size() > 1) { // Не удаляем начальное состояние
            stateStack_.pop();
        }
    }

    // Выполнение текущего состояния
    void request() {
        if (!stateStack_.empty()) {
            stateStack_.top()->handle();
        } else {
            std::cout << "Состояние не установлено!" << std::endl;
        }
    }
};

int main() {
    Context context;

    // Устанавливаем начальное состояние
    context.setInitialState(std::make_shared<ConcreteStateA>());

    char input;
    while (true) {
        std::cout << "Нажмите 'l' для изменения состояния, 'u' для отката или 'q' для выхода: ";
        std::cin >> input;

        if (input == 'l') {
            // Переключаем состояние
            context.changeState(std::make_shared<ConcreteStateB>());
        } else if (input == 'u') {
            // Откатываем состояние
            context.revertState();
        } else if (input == 'q') {
            break;
        }

        // Выполняем текущее состояние
        context.request();
    }

    return 0;
}
```

---

### Как это работает:
1. **Стек состояний**:
   - В классе `Context` используется стек (`std::stack`) для хранения состояний.
   - При изменении состояния новое состояние добавляется в стек.
   - При откате последнее состояние удаляется из стека, и возвращается предыдущее состояние.

2. **Методы**:
   - `changeState`: Добавляет новое состояние в стек.
   - `revertState`: Удаляет последнее состояние из стека (если это не начальное состояние).
   - `request`: Выполняет текущее состояние (верхний элемент стека).

3. **Пользовательский ввод**:
   - При нажатии `'l'` состояние меняется на `ConcreteStateB`.
   - При нажатии `'u'` состояние откатывается к предыдущему.
   - При нажатии `'q'` программа завершается.

---

### Пример работы программы:
```
Нажмите 'l' для изменения состояния, 'u' для отката или 'q' для выхода: l
Состояние B
Нажмите 'l' для изменения состояния, 'u' для отката или 'q' для выхода: u
Состояние A
Нажмите 'l' для изменения состояния, 'u' для отката или 'q' для выхода: q
```

---

### Преимущества:
- **Простота**: Использование стека делает логику отката интуитивно понятной.
- **Гибкость**: Можно добавлять новые состояния и управлять ими.
- **Безопасность**: Начальное состояние никогда не удаляется из стека.

Если нужно добавить больше состояний или изменить логику, дайте знать!