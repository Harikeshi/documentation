Паттерн **Состояние** (State) — это поведенческий паттерн проектирования, который позволяет объекту изменять свое поведение в зависимости от внутреннего состояния. Он используется, когда объект должен менять свое поведение во время выполнения программы, и когда это поведение зависит от его состояния.

### Как работает паттерн Состояние?

1. **Контекст (Context)**: Это класс, который содержит ссылку на текущее состояние и делегирует ему выполнение операций. Контекст не знает конкретных классов состояний, он работает с ними через общий интерфейс.

2. **Состояние (State)**: Это интерфейс или абстрактный класс, который определяет методы, которые должны быть реализованы всеми конкретными состояниями. Эти методы представляют собой действия, которые могут быть выполнены в контексте.

3. **Конкретные состояния (Concrete States)**: Это классы, которые реализуют интерфейс состояния. Каждый класс представляет отдельное состояние и определяет, как контекст должен вести себя в этом состоянии.

### Пример на C++

```cpp
#include <iostream>
#include <memory>

// Абстрактное состояние
class State {
public:
    virtual void handle() = 0;
    virtual ~State() = default;
};

// Конкретное состояние A
class ConcreteStateA : public State {
public:
    void handle() override {
        std::cout << "Handling state A" << std::endl;
    }
};

// Конкретное состояние B
class ConcreteStateB : public State {
public:
    void handle() override {
        std::cout << "Handling state B" << std::endl;
    }
};

// Контекст
class Context {
private:
    std::unique_ptr<State> state;

public:
    Context(std::unique_ptr<State> state) : state(std::move(state)) {}

    void setState(std::unique_ptr<State> newState) {
        state = std::move(newState);
    }

    void request() {
        state->handle();
    }
};

int main() {
    // Создаем контекст с начальным состоянием A
    Context context(std::make_unique<ConcreteStateA>());

    // Выполняем запрос в состоянии A
    context.request();

    // Меняем состояние на B
    context.setState(std::make_unique<ConcreteStateB>());

    // Выполняем запрос в состоянии B
    context.request();

    return 0;
}
```

### Как это работает:

1. **Контекст** содержит текущее состояние и делегирует ему выполнение операций.
2. Когда состояние меняется, контекст начинает вести себя по-другому, так как теперь он использует другой объект состояния.
3. **Конкретные состояния** реализуют поведение, соответствующее определенному состоянию контекста.

### Для чего применяется паттерн Состояние?

1. **Упрощение кода**: Паттерн Состояние позволяет избежать множества условных операторов, которые проверяют состояние объекта. Вместо этого каждое состояние инкапсулируется в отдельный класс.

2. **Гибкость**: Добавление новых состояний становится проще, так как нужно только создать новый класс состояния, не изменяя существующий код контекста.

3. **Управление сложными переходами**: Если переходы между состояниями сложные или зависят от многих факторов, паттерн Состояние помогает организовать этот процесс.

4. **Изоляция логики состояний**: Логика каждого состояния изолирована в отдельном классе, что делает код более читаемым и поддерживаемым.

### Примеры использования:

- **Редактор текста**: В зависимости от режима (например, режим вставки или режим замены), поведение редактора может меняться.
- **Игры**: Персонаж может находиться в разных состояниях (бег, прыжок, атака), и его поведение будет меняться в зависимости от текущего состояния.
- **Сетевые соединения**: Состояние соединения (подключено, отключено, ожидание) может влиять на поведение сетевого клиента.

Паттерн Состояние помогает сделать код более модульным и легко расширяемым, особенно в системах с большим количеством состояний и сложной логикой переходов между ними.
